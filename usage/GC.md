# JVM内存区域
![JVM Memory area](https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUrYqPicjVwjuMChPrPicNHdXXLVjV6CEdDmdicIfdEczgIFd29kNNjhRkGGHLWogaTWEiazsQVibgl9kg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
**虚拟机栈: 不需要GC，线程私有**，执行方法时的内存模型，生命周期和线程相同，执行方法时会创建**栈帧**(保存执行时的局部变量，操作数栈，动态连接和返回地址等信息，执行时入栈，结束时出栈，出栈就是清空数据)

**本地方法栈: 不需要GC，线程私有**，与虚拟机栈功能类似，区别在于虚拟机栈用于Java方法，而本地方法栈用于本地方法

**程序计数器: 不需要GC，线程独有**，记录当前线程执行的字节码执行到了第几行(就是记录下对应的行号)，因为多线程是通过线程轮流切换并分配CPU的时间来完成，任何时刻CPU只执行一个线程，若线程的时间片用完了就会被挂起，CPU会切换到另一个线程执行，下次轮到被挂起的线程时就需要通过记录在程序计数器中的行号指示器，通过它可以获取上一次被挂起时的状态，然后继续执行

**本地内存: 不需要GC，线程共享**，也就是**堆外内存**(包含了元空间和直接内存)

**堆: 需要GC，线程共享**，对象实例就是在堆上分配的

# 识别垃圾
## 引用计数法
概念：对象被引用一次就增加一次引用次数，引用次数为0就表示可以回收

**缺点：无法解决循环引用**，所以现代虚拟机都不用该方法判断
## 可达性算法
概念：一系列**GC Root**对象为起点出发，引出它们指向的下一个节点，再以此节点为起点，引出指向的下一个节点，以此类推，直到所有节点都遍历完毕，若对象不在任意一个GC Root为起点的**引用链**(GC Root串成的的一条线)中，则对象就可以回收，**现代虚拟机基本都用该算法判断对象能否回收**

**注意！**对象不可达不一定会被回收，对象的**finalize方法**给了最后一次机会，当不可达的对象发生GC时，会先判断对象是否执行了finalize，未执行就先执行，可以在finalize中将对象与GC Root进行关联，执行完后GC会再次判断对象是否可达，还是不可达就被回收

**还要注意！finalize只会执行一次！**第一次finalize后对象变成了可达没被回收，若对象被再次GC，就会忽略finalize，直接被回收了

### GC Root
**虚拟机栈中引用的对象**：其实就是方法中的局部变量(栈帧中的本地变量)，Hello a = new Hello(); 当a = null后，a就是GC Root，他和Hello类的实例断开了连接，所以实例就会被回收

**方法区中类静态属性引用的对象**：static修饰的类变量被赋值了对象的引用

**方法区中常量引用的对象**：static final修饰的类变量被赋值了对象的引用

**本地方法栈中JNI引用的对象**：本地方法以库文件形式存放(Windows是dll，Unix是so)，调用本地方法时，虚拟机保持Java栈不变，不会创建栈帧进行压栈操作，只是简单的进行动态连接

# 垃圾回收算法
## 标记清除算法
步骤：1. 根据可达性算法标记出可回收对象 2. 进行回收

**缺点：内存碎片**
## 复制算法
步骤：1. 将堆分为两块区域A和B，A负责分配对象，B不分配 2. 对A使用标记清除算法将存活对象标记出来 3. 将A中存活的对象都复制到B，并且**依次相邻排列** 4. 对A进行清理以释放空间

**缺点：1. 内存只有一半可用 2.每次回收都要移动存活对象，效率低下**
## 标记整理算法
步骤：步骤1和2，和标记清除算法相同 3.所有存活对象都往一端移动，**依次相邻排列**

**缺点：每次清除都要移动存活对象，效率低下**
## 分代收集算法
整合了以上所有算法，综合其优点，最大程度避免其缺点，现代虚拟机首选垃圾回收算法，其实就是一种策略

概念：根据**对象存活周期的不同**将堆分为新生代和老生代(默认比例1:2)，新生代又分Eden区，from Survivor区(简称S0)，to Survivor(简称S1)，默认比例8:1:1，新生代GC称为Young GC(也叫Minor GC)，老生代GC称为Old GC(也叫Full GC)

### 新生代
Java大部分对象都会在很短时间内被回收，一般分配在Eden区，即将填满时触发Minor GC，PS: 为什么比例是8:1:1，因为大部分对象都在Eden被回收了

步骤

1. 对Eden区进行一次Minor GC，标记可回收对象
2. 将存活对象移到S0，同时这些对象的年龄加一(年龄就是发生Minor GC的次数)
3. 清空Eden区以释放空间
4. 下一次Minor GC，对Eden和S0(或S1)标记可回收对象，将Eden区的存活对象和S0(或S1)中的存活对象(S0和S1中的存活对象每次Minor GC都可能被回收)一起移到S1(或S0)
5. 清空Eden区和S0(或S1)以释放空间
6. 下一次Minor GC就重复步骤4和5

每次回收，S0和S1角色互换，存活对象相互移动，其实这就是**复制算法**，不过因为大部分对象都在Eden区被回收了，剩下极少部分的存活对象，所以S0和S1的区域较小，最大程度降低了频繁复制对象带来的开销

### 新生代升老生代
对象的年龄到了设定的阀值时，就从S0或S1升为老生代

**当某个对象需要大量连续内存时，就直接分配在老生代**，若分配在Eden区，在Minor GC时移动到S0或S1会有很大的开销，S0和S1的空间也不够

当S0(或S1)相同年龄的对象大小之和大于S0(或S1)空间一半以上时，年龄大于等于该年龄的对象也会升为老生代

### 空间分配
Minor GC前，虚拟机会检查老生代最大可用的连续空间是否大于新生代所有对象之和，大于才能确保Minor GC安全，若不够则会查看HandlePromotionFailure，是否允许担保失败，允许就继续检查老生代最大可用的连续空间是否大于历次升为老生代的对象的平均大小，大于就进行Minor GC，否则可能进行Full GC

### Full GC
老生代满了，就会触发Full GC，会同时回收新生代和老生代，即整个堆，会导致Stop The World(简称STW，GC(Minor GC或Full GC)期间，只有垃圾回收线程在工作，其他线程全部挂起)，造成巨大的性能开销，Minor GC也可能导致STW，不过相对还好，因为大部分都被回收了

所以Eden, S0, S1的分区，对象设置年龄阀值，新老生代比例1:2，这些设计都是为了尽可能的避免对象过早进入老生代，尽可能晚的触发Full GC，S0和S1其实就是起到了一个缓冲区的作用，只有少数对象会进入老年代才能保证老生代空间不会过快增长，避免了过早触发Full GC

因为Minor GC和Full GC会影响性能，所以需要在合适的时间点触发GC，这个点就是Safe Point，不能太长(GC时间长导致程序卡顿)也不能太频繁(过分增大运行负荷)

Safe Point位置选择，一般是线程在这个点上的状态是确定的

1. 循环末尾
2. 方法返回前
3. 回调后
4. 抛出异常的位置

还需要注意，新生代Minor GC用的是复制算法，而老生代对象多且大，复制算法开销大，所以一般用标记整理算法进行GC


