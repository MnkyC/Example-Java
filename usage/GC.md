# JVM内存区域
![JVM Memory area](https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUrYqPicjVwjuMChPrPicNHdXXLVjV6CEdDmdicIfdEczgIFd29kNNjhRkGGHLWogaTWEiazsQVibgl9kg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
**虚拟机栈: 不需要GC，线程私有**，执行方法时的内存模型，生命周期和线程相同，执行方法时会创建**栈帧**(保存执行时的局部变量，操作数栈，动态连接和返回地址等信息，执行时入栈，结束时出栈，出栈就是清空数据)

**本地方法栈: 不需要GC，线程私有**，与虚拟机栈功能类似，区别在于虚拟机栈用于Java方法，而本地方法栈用于本地方法

**程序计数器: 不需要GC，线程独有**，记录当前线程执行的字节码执行到了第几行(就是记录下对应的行号)，因为多线程是通过线程轮流切换并分配CPU的时间来完成，任何时刻CPU只执行一个线程，若线程的时间片用完了就会被挂起，CPU会切换到另一个线程执行，下次轮到被挂起的线程时就需要通过记录在程序计数器中的行号指示器，通过它可以获取上一次被挂起时的状态，然后继续执行

**本地内存: 不需要GC，线程共享**，也就是**堆外内存**(包含了元空间和直接内存)

**堆: 需要GC，线程共享**，对象实例就是在堆上分配的

# 识别垃圾
## 引用计数法
概念：对象被引用一次就增加一次引用次数，引用次数为0就表示可以回收

**缺点：无法解决循环引用**，所以现代虚拟机都不用该方法判断
## 可达性算法
概念：一系列**GC Root**对象为起点出发，引出它们指向的下一个节点，再以此节点为起点，引出指向的下一个节点，以此类推，直到所有节点都遍历完毕，若对象不在任意一个GC Root为起点的**引用链**(GC Root串成的的一条线)中，则对象就可以回收，**现代虚拟机基本都用该算法判断对象能否回收**

**注意！**对象不可达不一定会被回收，对象的**finalize方法**给了最后一次机会，当不可达的对象发生GC时，会先判断对象是否执行了finalize，未执行就先执行，可以在finalize中将对象与GC Root进行关联，执行完后GC会再次判断对象是否可达，还是不可达就被回收

**还要注意！finalize只会执行一次！**第一次finalize后对象变成了可达没被回收，若对象被再次GC，就会忽略finalize，直接被回收了

### GC Root
**虚拟机栈中引用的对象**：其实就是方法中的局部变量(栈帧中的本地变量)，Hello a = new Hello(); 当a = null后，a就是GC Root，他和Hello类的实例断开了连接，所以实例就会被回收

**方法区中类静态属性引用的对象**：static修饰的类变量被赋值了对象的引用

**方法区中常量引用的对象**：static final修饰的类变量被赋值了对象的引用

**本地方法栈中JNI引用的对象**：本地方法以库文件形式存放(Windows是dll，Unix是so)，调用本地方法时，虚拟机保持Java栈不变，不会创建栈帧进行压栈操作，只是简单的进行动态连接

# 垃圾回收算法
## 标记清除算法
步骤：1. 根据可达性算法标记出可回收对象 2. 进行回收

**缺点：内存碎片**
## 复制算法
步骤：1. 将堆分为两块区域A和B，A负责分配对象，B不分配 2. 对A使用标记清除算法将存活对象标记出来 3. 将A中存活的对象都复制到B，并且**依次相邻排列** 4. 对A进行清理以释放空间

**缺点：1. 内存只有一半可用 2.每次回收都要移动存活对象，效率低下**
## 标记整理算法
步骤：步骤1和2，和标记清除算法相同 3.所有存活对象都往一端移动，**依次相邻排列**

**缺点：每次清除都要移动存活对象，效率低下**
## 分代收集算法
整合了以上所有算法，综合其优点，最大程度避免其缺点，现代虚拟机首选垃圾回收算法，其实就是一种策略

概念：根据**对象存活周期的不同**将堆分为新生代和老生代(默认比例1:2)，新生代又分Eden区，from Survivor区(简称S0)，to Survivor(简称S1)，默认比例8:1:1，新生代GC称为Young GC(也叫Minor GC)，老生代GC称为Old GC(也叫Full GC)

### 新生代
Java大部分对象都会在很短时间内被回收，一般分配在Eden区，即将填满时触发Minor GC，PS: 为什么比例是8:1:1，因为大部分对象都在Eden被回收了

步骤

1. 对Eden区进行一次Minor GC，标记可回收对象
2. 将存活对象移到S0，同时这些对象的年龄加一(年龄就是发生Minor GC的次数)
3. 清空Eden区以释放空间
4. 下一次Minor GC，对Eden和S0(或S1)标记可回收对象，将Eden区的存活对象和S0(或S1)中的存活对象(S0和S1中的存活对象每次Minor GC都可能被回收)一起移到S1(或S0)
5. 清空Eden区和S0(或S1)以释放空间
6. 下一次Minor GC就重复步骤4和5

每次回收，S0和S1角色互换，存活对象相互移动，其实这就是**复制算法**，不过因为大部分对象都在Eden区被回收了，剩下极少部分的存活对象，所以S0和S1的区域较小，最大程度降低了频繁复制对象带来的开销

### 新生代升老生代
对象的年龄到了设定的阀值时，就从S0或S1升为老生代

**当某个对象需要大量连续内存时，就直接分配在老生代**，若分配在Eden区，在Minor GC时移动到S0或S1会有很大的开销，S0和S1的空间也不够

当S0(或S1)相同年龄的对象大小之和大于S0(或S1)空间一半以上时，年龄大于等于该年龄的对象也会升为老生代

### 空间分配
Minor GC前，虚拟机会检查老生代最大可用的连续空间是否大于新生代所有对象之和，大于才能确保Minor GC安全，若不够则会查看HandlePromotionFailure，是否允许担保失败，允许就继续检查老生代最大可用的连续空间是否大于历次升为老生代的对象的平均大小，大于就进行Minor GC，否则可能进行Full GC

### Full GC
老生代满了，就会触发Full GC，会同时回收新生代和老生代，即整个堆，会导致Stop The World(简称STW，GC(Minor GC或Full GC)期间，只有垃圾回收线程在工作，其他线程全部挂起)，造成巨大的性能开销，Minor GC也可能导致STW，不过相对还好，因为大部分都被回收了

所以Eden, S0, S1的分区，对象设置年龄阀值，新老生代比例1:2，这些设计都是为了尽可能的避免对象过早进入老生代，尽可能晚的触发Full GC，S0和S1其实就是起到了一个缓冲区的作用，只有少数对象会进入老年代才能保证老生代空间不会过快增长，避免了过早触发Full GC

因为Minor GC和Full GC会影响性能，所以需要在合适的时间点触发GC，这个点就是Safe Point，不能太长(GC时间长导致程序卡顿)也不能太频繁(过分增大运行负荷)

Safe Point位置选择，一般是线程在这个点上的状态是确定的

1. 循环末尾
2. 方法返回前
3. 回调后
4. 抛出异常的位置

还需要注意，新生代Minor GC用的是复制算法，而老生代对象多且大，复制算法开销大，所以一般用标记整理算法进行GC

# 垃圾收集器
回收算法是内存回收的理论，回收内存的具体实现则需要靠垃圾收集器

Java虚拟机没有规定收集器该如何实现，厂商自己自定义

## 新生代垃圾收集器
### Serial
**复制算法，单线程**(只会用一个CPU或一个线程来完成收集)，并且在工作时，其他线程都会暂停，直到收集结束，也就是说在此期间是STW

**Clien模式**下，首先，其简单有效，无需和其他线程交互，降低了开销，能将单线程的优势发挥到极致；其次，分配给虚拟机的内存一般不会很大(几十甚至一两百兆)，STW时间可以控制在100多毫秒内，只要不是频繁收集，是可以接受的，所以**Client模式下的虚拟机，Serial是新生代的默认收集器**
### ParNew
**Serial的多线程版本，采用复制算法**，除了多线程，其他属性和Serial相同，底层上两者也共用了许多代码

其主要工作在**Server模式**，是**Server模式下的虚拟机的首选新生代垃圾收集器**，而且，**只有它能和CMS配合工作**

多CPU下，ParNew多线程的特性使得收集更快，减少STW时间，应用的响应速度也得到了提升
### Parallel Scavenge
和ParNew类似，也是采用**复制算法的多线程收集器**，和ParNew相比，他们的关注点不同，ParNew, CMS等垃圾收集器关注垃圾收集时用户线程的停顿时间，越短越好，而Parallel的目标是控制吞吐量(吞吐量=运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间))，即**ParNew, CMS等更适合用于和用户交互的程序，停顿时间短，用户体验好，Parallel关注吞吐量，更适合做后台运算等不需要交互的任务**

**Parallel提供两个参数来精确控制吞吐量**(控制最大垃圾收集时间的**-XX:MaxGCPauseMillis**以及设置吞吐量大小的**-XX:GCTimeRatio**(默认99%))，还可以用**-XX:UseAdaptiveSizePolicy**，开启该参数后就不需要手动设置新生代大小，Eden和Survivor的比例等细节，只需要设置堆大小(-Xmx设置最大堆)，最大垃圾收集时间，吞吐量大小，虚拟机就会根据当前系统的运行情况收集监控信息，动态调整参数以达到设置的最大垃圾收集时间和吞吐量大小这两个指标

**Parallel的自适应策略**也是和ParNew的不同之处
## 老生代垃圾收集器
### Serial Old
相对于新生代的Serial(单线程收集器)，Serial Old是老生代的单线程收集器，也是用于Client模式下的虚拟机，不过其**采用的是标记整理算法**
### Parallel Old
相对于新生代的Parallel Scavenge，Parallel Old是老生代的版本，采用**标记整理算法的多线程收集器**
### CMS
划时代的垃圾收集器，**真正的并发收集器**，第一次实现了垃圾收集器和用户线程同时工作，采用传统GC收集器的框架，与Serial，ParNew共用一套框架

以实现最短STW时间为目标，若应用很看重服务的响应速度以及用户体验，可以试下CMS

老生代主要是标记整理算法，而**CMS采用标记清除算法**

步骤

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

缺点

1. 对CPU资源非常敏感，默认启动的回收线程数是(CPU数量 + 3) / 4，若CPU数量太少，吞吐量就直接下降了
2. 无法处理浮动垃圾，可能因为**Concurrent Mode Failure**导致另一次Full GC的产生，由于并发清理时用户线程还在运行，所以在清理时垃圾也在不断产生，这些垃圾只能等下次GC(这些垃圾就是“浮动垃圾”)，而且需要预留足够的空间确保用户线程正常执行，所以CMS不能等老生代满了再使用，JDK5默认老生代使用了68%后就激活CMS(可通过**-XX:CMSInitialingOccupancyFraction**设置)，若太高就很容易导致CMS运行时无法预留足够的空间来满足程序运行，导致Concurrent Mode Failure，这时会启动Serial Old进行重新收集，而Serial Old是单线程的，STW时间会更长
3. 标记清除算法会产生大量的内存碎片，当然，可以开启**-XX:+UseCMSCompactAtFullCollection**(默认开启，用于顶不住要进行Full GC时开启内存碎片的合并整理)，但是内存整理会导致STW，停顿时间变长，不过还可以设置**-XX:CMSFullGCsBeforeCompaction**来控制执行多少次不压缩的Full GC后进行一次带压缩的Full GC

## 新老生代都用的垃圾收集器
### G1(Garbage First)
面向服务端的垃圾收集器

特点

1. 像CMS一样，能与应用程序线程并发执行
2. **整体采用标记整理算法，局部采用复制算法**，不会产生内存碎片
3. 在STW基础上建立可预测的停顿时间模型，可以自定义期望停顿时间

为什么能建立可预测的停顿时间模型？

因为G1对堆堆分配和传统垃圾收集器不同，传统的内存分配都是连续的，而G1是不连续的，每一代都适用n个不连续的大小相同的Region，每个Region占用一块连续的内存

传统的内存分为新老生代，除了Eden, Survivor, Old，G1还多了一个H区，存储大小大于等于Region一半空间的巨大对象，直接分配到老生代，防止了反复拷贝移动

传统收集器发生Full GC是对整个堆进行垃圾收集，而分配成多个Region，方便G1跟踪分析各个Region中垃圾堆积的价值大小，这样就能维护一个优先列表，根据允许的收集时间，优先收集回收价值高的Region，避免了整个老生代的回收，减少STW时间

步骤

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

# 总结
根据不同场景组合不同的垃圾收集器，对于Client模式，可以用Serial+Serial Old，对于响应速度快，用户体验好的，可以用ParNew+CMS