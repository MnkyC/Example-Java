**为了系统的可维护性，可复用性，可扩展性，灵活性，从而提高开发效率，节省开发和维护成本，需要遵守一定的开发原则**

# 七大设计原则
## 开闭原则，Open Closed Principle
**对扩展开放，对修改关闭**，当需求修改时**不改变实体的源代码和二进制代码**，通过**扩展实现新需求**

### 实现
使用**接口**或者**抽象类**为系统定义一个相对稳定的抽象层，将相同的可变元素封装在具体实现类中

## 里氏替换原则，Liskov Substitution Principle
**对开闭原则的补充**

子类可以扩展父类的功能，但是不能改变父类的原有功能，即**用新方法完成新需求，而不是重写父类方法**

如，企鹅虽然是鸟类，但是它不会飞，所以就不能定义为鸟的子类
### 实现
抽象更上一层的父类

## 依赖倒置原则，Dependence Inversion Principle
**面向接口**编程，**依赖抽象**，降低类之间的耦合

### 实现
尽量使用接口和抽象类，任何类都不要从具体类派生，继承尽量遵守里氏替换原则

## 单一职责原则，Single Responsibility Principle
控制类的粒度大小，降低类的复杂度，一个类只负责某一个**职责**

约束类，针对类中的实现和细节

### 实现
根据不同职责进行分离，封装成不同的类或模块

## 接口隔离原则，Interface Segregation Principle
使用多个隔离的接口而不是单个接口，降低依赖和耦合

约束接口，为类创建其专有的接口，控制接口的粒度大小

### 实现
接口要有限度，一个接口只服务于一个子模块或业务

为类定制服务，只暴露需要的方法

## 迪米特法则（最少知道原则），Least Knowledge Principle
实体类尽量保持独立，不与其他实体发生相互作用，可以通过第三方进行转发调用

会产生很多中介类，注意平衡
### 实现
尽量创建弱耦合的类

降低类中成员的访问权限

尽量降低引用其他类的次数

不要暴露成员，用get和set

## 合成复用原则，Composite Reuse Principle
尽量使用**合成/聚合**的方式而不是继承，用继承就遵守里氏替换原则

继承的弊端

	破坏了封装性，会将父类的实现细节暴露给子类，即“白箱”复用
	子类和父类耦合度高，父类改变会导致子类实现发生变化
	限制了复用的灵活性，编译时已经确定继承而来的实现

组合优点

	维护了类的封装性，成员对象内的实现细节对于新对象是透明的，即“黑箱”复用
	类之间的耦合度低，获取成员对象中的方法只能通过成员对象的接口
	复用灵活性高，运行时可动态进行复用

### 实现
将已有对象纳入新对象，作为新对象的成员对象，新对象可通过已有对象实现功能，达到复用的目的

# 建议
开闭是总则，里氏不破继，倒置向接口，单一是职责，隔离对接口，最少降耦合，合成可复用
